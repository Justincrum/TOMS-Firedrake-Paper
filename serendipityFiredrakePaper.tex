%%Trying out a new ordering for the paper.
%%
%% This is file `sample-manuscript.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `manuscript')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-manuscript.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
%%%% Small single column format, used for CIE, CSUR, DTRAP, JACM, JDIQ, JEA, JERIC, JETC, PACMCGIT, TAAS, TACCESS, TACO, TALG, TALLIP (formerly TALIP), TCPS, TDSCI, TEAC, TECS, TELO, THRI, TIIS, TIOT, TISSEC, TIST, TKDD, TMIS, TOCE, TOCHI, TOCL, TOCS, TOCT, TODAES, TODS, TOIS, TOIT, TOMACS, TOMM (formerly TOMCCAP), TOMPECS, TOMS, TOPC, TOPLAS, TOPS, TOS, TOSEM, TOSN, TQC, TRETS, TSAS, TSC, TSLP, TWEB.
% \documentclass[acmsmall]{acmart}

%%%% Large single column format, used for IMWUT, JOCCH, PACMPL, POMACS, TAP, PACMHCI
% \documentclass[acmlarge,screen]{acmart}

%%%% Large double column format, used for TOG
% \documentclass[acmtog, authorversion]{acmart}

%%%% Generic manuscript mode, required for submission
%%%% and peer review
\documentclass[manuscript,screen]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
%%\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
%%  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
%\acmPrice{15.00}
%\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\usepackage{subcaption}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{listings}


\DeclareMathOperator{\Div}{div}
\DeclareMathOperator{\curl}{curl}

\newcommand{\R}{\mathbb{R}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand\akg[1]{\textbf{\textcolor[rgb]{.5,0,1}{[Andrew: #1]}}}
\newcommand\josh[1]{\textbf{\textcolor[rgb]{0,.5,1}{[Josh: #1]}}}

\newcommand{\calP}{\mathcal{P}}
\newcommand{\calQ}{\mathcal{Q}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\hcurl}{$H($curl$)$}
\newcommand{\hdiv}{$H($div$)$}

\newcommand{\cancel}[1]{}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Bringing Trimmed Serendipity Methods to Computational Practice in Firedrake}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.

\author{Justin Crum}
\email{jcrum@math.arizona.edu}
\affiliation{%
  \institution{University of Arizona}
  \city{Tucson}
  \state{Arizona}
}

\author{Cyrus Cheng}
\email{cyrus.cheng15@imperial.ac.uk}
\affiliation{%
  \institution{Imperial College}
  \city{London}
  \country{United Kingdom}
}

\author{David Ham}
\affiliation{%
  \institution{Imperial College}
  \city{London}
  \country{United Kingdom}
}
\email{david.ham@imperial.ac.uk}

\author{Lawrence Mitchell}
\affiliation{%
  \institution{Durham University}
  \city{Durham}
  \country{United Kingdom}}
\email{wence@gmx.li}

\author{Robert Kirby}
\affiliation{%
 \institution{Baylor University}
 \city{Waco}
 \state{Texas}
}
\email{robert_kirby@baylor.edu}

\author{Joshua A. Levine}
\affiliation{%
  \institution{University of Arizona}
}
\email{josh@email.arizona.edu}

\author{Andrew Gillette}
\affiliation{%
  \institution{University of Arizona}
  \city{Tucson}
  \state{Arizona}}
\email{agillette@math.arizona.edu}
%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%\renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.

\begin{abstract}
       We present the first complete \josh{``complete'' is maybe a bit strong as it implies \emph{everything}?} implementation of the trimmed serendipity finite element family, using the open source finite element package Firedrake.  The new elements can be used seamlessly within the software suite for problems requiring $H^1$, \hcurl~or \hdiv-conforming elements on affinely mapped meshes of squares or cubes.  To test how well trimmed serendipity elements perform in comparison to traditional tensor products elements, we perform a sequence of numerical experiments including the primal Poisson, mixed Poisson, and Maxwell cavity eigenvalue problems.  Overall, we find that the trimmed serendipity elements converge, as expected, at the same rate as the respective tensor product elements while being able to offer significant savings in the time or memory required to solve certain problems.
\end{abstract}
  
  
  \maketitle
  
  
  \section{Introduction}
  
  In addition to the four families of finite elements present on the Periodic Table of Finite Elements \cite{arnold2014periodic}, recent research has examined a fifth family, called the \emph{trimmed serendipity finite elements}.  Similar to their tensor product and ``regular'' serendipity counterparts,  trimmed serendipity elements provide another finite element method for approximating the solution to partial differential equations on square or cubical meshes.  While potential computational advantages of these new elements have been described in previous works, they have never been realized or tested in a modern finite element package.  In particular, we expect that the serendipity and trimmed serendipity elements should be able to attain the same rate of convergence as tensor product elements while requiring fewer degrees of freedom to do so.  By implementing the trimmed serendipity and tensor product elements in the same software package, we \josh{seek to make these elements availability to broader finite element community while assessing} their computational advantages in a common and practical setting for the first time.
  
  %(The prior sentence will need further revisions - just taking a stab at it.  The previous sentence: To remedy this, we will present an implementation in Firedrake for $H^1$-, $H($curl$)$, and $H($div$)$ conforming trimmed serendipity elements in both $n=2,3$ dimensions for arbitrary orders $r$.)
  
  In this paper, we present a complete \josh{this version of ``complete'' is scoped more appropriately than in the abstract} implementation of the trimmed serendipity element family in 2D and 3D within the Firedrake finite element package \cite{rathgeber2016firedrake}, accompanied by a suite of numerical experiments demonstrating their approximation accuracy and potential benefits on benchmark partial differential equation problems.
  % computational challenges.
  % which can be found in section 4.  
Firedrake is a Python package 
that brings together many useful mathematics packages to create a user-friendly Python library \josh{``many useful mathematics packages'' is pretty vague.  Should we just cut this phrase out?  Could also list those packages}
for approximating the solution to partial differential equations (PDEs) via finite elements. Firedrake makes the approximation of solutions to PDEs simple by using the unified form language (UFL) package, which has the capability of mimicking mathematical notation.  

An example of writing a discretized PDE and solving it in Firedrake can be found in Listing~\ref{lst:mixedPoissonCode}, where we illustrate how to solve the mixed Poisson problem using Firedrake.  To do this, we first write the mixed Poisson equation on a domain $\Omega = [0, 1] \times [0,1]$ with boundary $\Gamma$ in the weak formulation, where we are solving for $\sigma \in \Sigma$ and $\nu \in V$ such that the following equations are satisfied:

\begin{equation*}
    \int_\Omega (\sigma \cdot \tau + \nabla \cdot \tau u) \text{d}x = \int_\Gamma \tau \cdot n \text{ } u \text{ d}s \text{  } \forall \tau \in \Sigma
\end{equation*}
\begin{equation*}
    \int_\Omega  \nabla \cdot \sigma \nu \text{d}x = - \int_\Gamma f \nu \text{ d}s \text{  } \forall \nu \in V.
\end{equation*}
  
\noindent Solving the discretized version of this requires a suitable pairing of finite element spaces to create a stable method.  One example of that is using {\fontfamily{qcr}\selectfont RTCF} as the vector element and {\fontfamily{qcr}\selectfont DQ} as the scalar element to get a tensor product pairing (later for trimmed serendipity, we will use {\fontfamily{qcr}\selectfont SminusDiv} and {\fontfamily{qcr}\selectfont DPC} for the vector and scalar elements, respectively).  \josh{Do we think our readers know what ``RTCF'', ``DQ'', ``SminusDiv'', and ``DPC'' all mean?  Perhaps we need to elaborate.}  As seen in Listing \ref{lst:mixedPoissonCode}, the order of these elements needs to be offset so that the scalar elements are 1 degree less than the vector elements, which is true in the trimmed serendipity scenario as well.  \josh{why this needs to happen isn't quite clear from the paragraph}
  
  %
  % AG NOTE: I added the lstset basic style command below to switch to a monospaced font 
  % 
  \lstset{language=Python}
  \lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
  \begin{lstlisting}[frame=single, caption={Basic Firedrake implementation of the mixed Poisson problem showcasing where to choose the elements that are used and how to create the equations in Firedrake's notation.}, label={lst:mixedPoissonCode}, numbers=left, firstnumber=1, xleftmargin=20pt, xrightmargin=20pt]]
    PolyDegree = 2
    Cells = 2**5
    mesh = UnitSquareMesh(Cells, Cells, quadrilateral=True)
    DQ = FunctionSpace(mesh, "DQ", PolyDegree - 1)
    RTCF = FunctionSpace(mesh, "RTCF", PolyDegree)
    W = RTCF * DQ
    
    sigma, u = TrialFunctions(W)
    tau, v = TestFunctions(W)
    
    x, y, z = SpatialCoordinate(mesh)
    uex = sin(pi*x)*sin(pi*y)*sin(pi*z)
    sigmaex = grad(uex)
    
    f = -div(grad(uex))
    a = (dot(sigma, tau) + div(tau)*u + div(sigma)*v)*dx
    L = -f*v*dx
    w = Function(W)
        ...
    solve(a == L, w, solver_parameters=params)
  \end{lstlisting}

  
  
	An important strength of Firedrake is its modular structure for both users and developers.
   For the user, swapping to trimmed serendipity elements to solve the mixed Poisson problem is as easy as modifying lines 4-5 in Listing~\ref{lst:mixedPoissonCode} to the appropriate identifiers, {\fontfamily{qcr}\selectfont DPC} and {\fontfamily{qcr}\selectfont SminusDiv} inside the {\fontfamily{qcr}\selectfont FunctionSpace} calls.  
   %While ease of use for practitioners is one reason for choosing Firedrake as a library for implementing trimmed serendipity elements, it is not the only one.    
   For developers, implementing a new element type -- such as trimmed serendipity -- is simply a matter of defining a suitable computational basis and connecting it to the intermediate interfaces in the included libraries.  We implement the basis functions from~\cite{gillette2019computational} that are already associated to portions of the square or cube geometry (vertices, edges, faces, interior) and then use them within an existing data structure (FIAT) for processing.
   
   Having these available in Firedrake allows users to test the theoretical limits that the trimmed serendipity elements are trying to attain.  In 2D, the trimmed serendipity elements at low orders have fewer, though similar, numbers of degrees of freedom to tensor product and serendipity elements.  However, as the degree of the elements are increased, the gap between the number of degrees of freedom for trimmed serendipity elements and tensor product elements starts to increase.  
   
   While the formulae for the dimensions of each space are somewhat involved, a simple count of degrees of freedom in a standard case highlights the potential gains.
	To implement a standard mixed method, similar to what was done above, for the Darcy flow with quadratic order error decay ($r=2$) in the velocity estimate ($k=2$), the divergence of the velocity ($k=3$) and the pressure ($k=3$), on a single cube ($n=3$) the pair of $\calQ^-$ elements used have a total of 44 degrees of freedom, the regular serendipity elements have 43 degrees of freedom, but the trimmed serendipity have only 25 degrees of freedom. 
  \josh{the previous sentence is cumbersome and might benefit from breaking apart}
	The difference in degree of freedom count grows with $r$, meaning the computational savings accrued by trimmed serendipity should be most dramatic for larger $r$ values.
	Seeing how such back-of-the-envelope calculations might bear out in a practical context requires the thorough implementation provided in this paper.
   
   
   %\akg{The rest of the intro goes into a detailed example as we discussed but I don't think this is the right place for it.  This fits more naturally into Section 3 where the notation will already have been defined and it makes sense to go into some detail.  Instead, I think the intro should have 1-2 more paragraphs highlighting the expected benefits of trimmed serendipity elements (huge reduction in DoFs in 3D, for higher order) and summarizing the major contributions.  We can discuss at our next meeting.}
   %Combinations of these sets of basis functions are what will create the basis functions for the trimmed serendipity reference element.  For instance, a basis for $\calS^-_r\Lambda^1(\square_3)$, the trimmed serendipity $H($curl$)$-conforming element in 3D, can be decomposed as
   
   %\begin{equation}\label{eq:HCurlTrimmedSerendipityBasis}
   %\calS^-_r\Lambda^1(\square_3) =    \left[\bigoplus_{i=0}^{r-1} E_i %\Lambda^1\right]\oplus\left[ \bigoplus_{i=2}^{r-1}F_i \Lambda^1\right] \oplus %\left[\tilde{F}_r \Lambda^1\right]\oplus\left[ \bigoplus_{i=4}^{r-1}I_i \Lambda^1 %\right] \oplus \left[\tilde{I}_r \Lambda^1\right].
   %\end{equation}
   
  %Functions here have the basic naming scheme that any set denoted with a $V$ are functions defined on the vertices, sets denoted with $E$ or $\tilde{E}$ are functions defined on the edges, sets denoted with $F, \tilde{F}, \hat{F}$ are functions defined on the faces, and the sets denoted with an $I$ or $\tilde{I}$ are defined on the interior of the cube in 3d. 
  
  %\begin{example}\label{ex:UsingComputationalBasis}
  %To illustrate how equation \ref{eq:HCurlTrimmedSerendipityBasis} works, consider the case of $\calS_1^-\Lambda^1(\square_3)$.  In this scenario, $r=1$, and so we ignore the sets $F_i\Lambda^1$, $\tilde{F}_r\Lambda^1$, $I_i \Lambda^1$ and $\tilde{I}_r\Lambda^1$.  This means we only need to focus on the functions associated to the edge of the reference element.  These functions form a basis of $12$ functions that all have the form of
  
  %\begin{equation*}
  %    (y\pm 1)(z\pm 1)dx + (x\pm 1)(z\pm 1) dy + (x \pm 1)(y \pm 1)dz.
  %\end{equation*}
  
  %Notice that, give a specific edge of $\square_3$, we can identify exactly one of the 12 possible basis functions to it.  For example, if we are interested in the edge such that $y=1, z=1$, we know that $dy = dz = 0$, and thus the only nonzero basis function must be nonzero in the $dx$ component. Therefore, the $y=1, z=1$ edge is associated to the basis function $(y+1)(z+1)dx$.  This is an important aspect of the basis functions that Firedrake makes use of to ensure that basis functions are associated to the proper degree of freedom on the reference element.
  %\end{example}
  
Summarizing, the contributions of this paper are that we:
  \begin{enumerate}
      \item show how the Firedrake software environment can be used to implement trimmed serendipity elements and allow a user to work with these elements with only small changes to their existing code, 
      \item illustrate trimmed serendipity finite elements achieving the theoretical bounds that are predicted in terms of convergence rates, and  
      \item examine the costs and benefits of using trimmed serendipity elements within the confines of typical test problems for numerical analysis by comparing them to tensor product elements.
  \end{enumerate}
  
  
  %In the next section, we will give more background on the trimmed serendipity elements that will explain where these basis functions come from.  This is followed by an explanation of what Firedrake is and how it makes implementing and using new finite elements easy in the third section.  Finally in section 4, we focus on various numerical experiments comparing the efficiency of using tensor product and trimmed serendipity elements.  
  
  \section{Background and notation for trimmed serendipity elements}
   
    Over the last 15 years, conforming finite element methods for Hodge-Laplace type problems on simplicial and cubical meshes have been categorized using the language of Finite Element Exterior Calculus (FEEC)~\cite{AFW2006,AFW2010,ABB2012}.  Among its many advantages, FEEC gives an easy, unified way to notate different element types.  The four best known families of elements are denoted $\calP^-_r \Lambda^k$, $\calP_r \Lambda^k$, $\calQ^-_r \Lambda^k$, and $\calS_r \Lambda^k$, which are, respectively, the trimmed polynomial, polynomial, tensor product, and serendipity elements of order $r$ using $k$-forms.  The $\calP$ and $\calP^-$ spaces are defined over meshes of simplices (triangles, tetrahedra, etc) while the $\calQ^-$ and $\calS$ spaces are defined over meshes of hypercubes (squares, cubes, etc). The optional notation $(\square_n)$ denotes the spaces used specifically for $n$-dimensional cubes in $\R^n$, but we will frequently omit this addition if $n$ is clear from context.
    
    The mathematical results from FEEC regarding these four families families synthesize decades of research into what constitutes a stable finite element, i.e.\ a numerical method that can be proven to converge to the correct solution of certain PDEs in certain norms at a prescribed rate, indicated by the subscript $r$.  In any dimension, the $0$-form spaces provide scalar-valued, $H^1$-conforming elements.  In 2D, $1$-forms can represent both \hcurl~and \hdiv~elements, depending on the orientation of the degrees of freedom defined on the edges of a mesh.  In 3D, $1$-forms correspond to \hcurl~elements while $2$-forms correspond to \hdiv~elements.  
        
    
  \subsection{Trimmed Serendipity Elements}
    The trimmed serendipity family is a relatively new addition to this collection that attains a key optimality condition arising from the FEEC framework.
	In~\cite{christiansen2016constructions}, Christiansen and Gillette computed the minimal possible dimensions for an exact sequence of finite element spaces on cubes that contained $\calP_r\Lambda^k$ for each $k$.
	In~\cite{gillette2019trimmed}, Gillette and Kloefkorn identified polynomial differential form spaces with these prescribed dimensions and approximation power, denoting them trimmed serendipity elements with the notation $S^-_r\Lambda^k$.  
	The trimmed serendipity spaces share the same interleaving containment structure with the serendipity spaces as the polynomial and trimmed polynomial subspaces have.  That is, for any fixed dimension $n$, any form order $0\leq k\leq n$, and any approximation order $r\geq 1$, we have both
\begin{equation*}
      \calS_r \Lambda^k \subset \calS^-_{r+1} \Lambda^k \subset \calS_{r+1} \Lambda^k
  \end{equation*}
 \noindent and   
   \begin{equation*}
      \calP_r \Lambda^k \subset \calP^-_{r+1} \Lambda^k \subset \calP_{r+1} \Lambda^k.
  \end{equation*}
	These containments express the fact that typically a finite element practitioner will get the most computational efficiency for a desired approximation order by choosing an appropriate $\calP^-$ space instead of a $\calP$ space.
	An equivalent claim is implied about serendipity and trimmed serendipity spaces, with additional comparison to the larger dimensional tensor product spaces, $\calQ^-$, possible as well.


	
%	Many additional mathematical properties proved in~\cite{gillette2019trimmed} solidify the analogue between the $\calP_r^-\Lambda^k$ and $\calS_r^-\Lambda^k$ families.

    
    
%Solving partial differential equations on cubical meshes has been a topic of many different finite element studies. In 3D, this includes the $H($curl$)$ and $H($div$)$ Nedelec elements. However, this ignores the other two families of finite element differential forms for square and cubical meshes, the serendipity and trimmed serendipity elements.
  
%  In \cite{arnold2011serendipity}, Arnold and Awanou described the shape functions for Serendipity elements $\mathcal{S}_r$ in $n$ dimensions as the space of polynomials with superlinear degree in at most $n$ variables, denoted as $deg_2 p$, such that $deg_2 p \leq r$. This gave serendipity elements a concrete definition in $n$ dimensions. Moreover, they showed that serendipity elements defined in such a way can be assigned a set of unisolvent degrees of freedom and that there is a nice way to give a geometric decomposition of the serendipity elements.
  

% Following this, Gillette and Kloefkorn then introduced the trimmed Serendipity elements $S^-_r$ in \cite{gillette2019trimmed}.  The trimmed serendipity elements are the answer to the question ``Does there exist a minimal compatible finite element system on cubes containing $P_r \Lambda^k$?'', and contain the expected amount of interior degrees of freedom as described by Christiansen and Gillette in \cite{christiansen2016constructions}.  
  
    
	As a step toward testing such ideas, Gillette, Kloefkorn and Sanders gave a systematic way to build the computational basis for each of these elements for dimensions $n = 2, 3$, $k=0, 1, 2, 3$-forms, and arbitrary order $r \geq 1$~\cite{gillette2019computational}.
	Prior to this paper, neither these bases nor any other general implementation of trimmed serendipity elements has been attempted.
  %Using these basis functions, we implemented the trimmed Serendipity elements in 2 and 3 dimensions inside of Firedrake, a python package for solving partial differential equations using finite element methods. 
  %  The trimmed serendipity elements in both 2D and 3D can be defined in terms of the $k$-forms used to represent them, or the type of space they conform to.
  
  
  %\akg{I think a lot of the rest of Section 2 should be cut, actually.  @Justin: I suggest you copy the text below to a file of notes / text that could go into your thesis since it may be appropriate there. I'll think on this some more and push some more edits on Friday.}
  \subsubsection{Scalar Trimmed Serendipity Elements}
  The scalar-valued trimmed serendipity elements that are represented by $0$-forms are used as the shape functions for an $H^1$-conforming finite element space.  These are denoted by $\calS_r^-\Lambda^0$ and are identical to the scalar-valued serendipity elements from the Periodic Table of Finite Elements, i.e.\ $\calS_r^-\Lambda^0(\square_n) = \calS_r\Lambda^0(\square_n)$ for any $n$.  Arnold and Awanout provided a simple description of the shape functions for these spaces as the span of all monomials of ``superlinear degree'' less than or equal to $r$~\cite{arnold2011serendipity}. 
  
  Likewise, the scalar-valued trimmed serendipity elements that are represented by $n$-forms create $L^2$-conforming finite element spaces.  These are denoted by $\calS_r^-\Lambda^n(\square_n)$, and here we have the equality $\calS_r^-\Lambda^n(\square_n) = \calS_{r+1}\Lambda^n(\square_n)$.  In terms of the Periodic Table of Finite Elements, these are the \textbf{dPc}$_r$ spaces.  The shape functions for these spaces are simply the space of order $r$ polynomials.  Since no inter-element continuity is needed for $L^2$-conformity, we have the additional equivalence $\calS_r^-\Lambda^n(\square_n) = \calP_{r+1}\Lambda^n(\square_n)$.
  
  \subsubsection{Vector Trimmed Serendipity Elements}
  
\akg{Talk about Arnold Awanou paper:~\cite{arnold2014finite} and Arbogast Correa paper~\cite{arbogast2016two}}

	The trimmed serendipity elements are truly distinct from regular serendipity spaces for $k$ values $0<k<n$.  We will only consider dimensions $n=2$ and $n=3$, where the $k$-form spaces can be identified as vector-valued finite elements.  First we look at the case $k=n-1$, i.e.\ the \hdiv-conforming element families $\calS_r^-\Lambda^1(\square_2)$ and $\calS_r^-\Lambda^2(\square_3)$. 
	\akg{Still editing from here}
	
%At $k=0$ and $k=n$, the trimmed serendipity spaces coincide with regular serendipity spaces, but for intermediate values of $k$ and $r>1$, the containments are strict and hence the dimensions 
  
  The vector trimmed serendipity elements can be split into two groups: 1-forms and $(n-1)$-forms.  
  
  The first group normally discussed are the $2$-forms in 3D and $1$-forms in 2D, .  Both are \hdiv-conforming finite elements.  Unfortunately, the vector trimmed serendipity elements do not have a ``nice'' definition for their shape functions.  Instead, we have the definition that in general, 
  \begin{equation*}
      \calS_r^-\Lambda^k = \calS_{r-1}\Lambda^k + \kappa \calS_{r-1}\Lambda^{k+1}
  \end{equation*}
  where $\kappa$ is the Kozsul differential operator, and $k=2$ in 3D, $k=1$ in 2D.  This is a more difficult definition to work with, which emphasizes the importance of having the computational bases, such as the one shown in \ref{ex:UsingComputationalBasis}.  
  
  In 3D, the $1$-forms that are used to represent an \hcurl-conforming finite element space also are defined using the shape forms as described above, using $k=1$ instead of $k=2$.  In 2D, the \hcurl-conforming finite element space is simply a rotation of the \hdiv-space.  
  
  For each of these different types of elements, we present experiments in section 4 that detail how the trimmed serendipity elements compare to the corresponding tensor product elements.  The scalar $H^1$-conforming elements are used in the primal Poisson problem, while the scalar $L^2$-conforming elements are used in the mixed Poisson problem.  For the vector elements, the \hdiv-conforming elements are used in the mixed Poisson problem while the \hcurl-conforming elements are tasked with solving the Maxwell cavity eigenvalue problem.
  
  
  
  
  \section{Building capacity for serendipity element types in Firedrake}
  \label{sec:buildcap}
  
  Firedrake is a Python package that is made to solve finite element problems.  It does this by tying together many packages in a cohesive manner.  For implementing a new finite element, we can focus on a few specific packages, namely FIAT, FInAT, UFL, and TSFC (\cite{alnaes2012ufl},\cite{hamfinat},\cite{homolya2017exposing}, \cite{homolya2018tsfc}, \cite{kirby2004algorithm}, \cite{kirby2012fiat}).  
  
 The first step in implementing the trimmed serendipity elements was to focus on using FIAT.  Inside FIAT (FInite element Automatic Tabulator), we can create classes that provide the basis functions for the trimmed serendipity elements and tabulate them.  We break down the basis functions into distinct sets dependent upon the dimension of the mesh element they correspond to (vertices, edges, faces, or cell interiors).  For instance, a basis for $\calS^-_r\Lambda^1(\square_3)$, the trimmed serendipity $H($curl$)$-conforming element in 3D, can be decomposed as
   \begin{equation}\label{eq:HCurlTrimmedSerendipityBasis}
   \calS^-_r\Lambda^1(\square_3) =    \left[\bigoplus_{i=0}^{r-1} E_i \Lambda^1\right]\oplus\left[ \bigoplus_{i=2}^{r-1}F_i \Lambda^1\right] \oplus \left[\tilde{F}_r \Lambda^1\right]\oplus\left[ \bigoplus_{i=4}^{r-1}I_i \Lambda^1 \right] \oplus \left[\tilde{I}_r \Lambda^1\right].
   \end{equation}
   
  Functions here have the basic naming scheme that any set denoted with an $E$ are defined on edges, sets denoted with an $F$ are functions defined on faces, and sets denoted with $I$ are functions defined on the interior of the cubical cell in 3d.
  
  \begin{example}\label{ex:UsingComputationalBasis}
  To illustrate how equation \ref{eq:HCurlTrimmedSerendipityBasis} is implemented, consider the components of $\calS_1^-\Lambda^1(\square_3)$.  In this scenario, $r=1$, and so we ignore the sets $F_i\Lambda^1$, $\tilde{F}_r\Lambda^1$, $I_i \Lambda^1$ and $\tilde{I}_r\Lambda^1$ (to see the exact formulation for each of these sets, see Gillette \cite{gillette2019computational}).  This means we only need to focus on the functions associated to the edge of the reference element.  These functions create a basis of $12$ functions that all have the form 
  \begin{equation*}
      (y\pm 1)(z\pm 1)dx + (x\pm 1)(z\pm 1) dy + (x \pm 1)(y \pm 1)dz.
  \end{equation*}
  
  Notice that, given a specific edge of $\square_3$, we can identify exactly one of the 12 possible basis functions to it.  For example, if we are interested in the edge such that $y=1, z=1$, we know that $dy = dz = 0$, and thus the only nonzero basis function must be nonzero in the $dx$ component. Therefore, the $y=1, z=1$ edge is associated to the basis function $(y+1)(z+1)dx$.  This is an important aspect of the basis functions that Firedrake makes use of to ensure that basis functions are associated to the proper degree of freedom on the reference element.
  \end{example}
 
To see how this plays out in the Firedrake implementation, consider the \hcurl~elements for trimmed serendipity at order $r=2$ in $n=3$ dimensions, indicating the space $S_2^- \Lambda^1$ in 3d. According to Equation~\ref{eq:HCurlTrimmedSerendipityBasis}, these require using two sets of functions, one set on the edges of the reference element and one set on the faces of the reference element. For example, when we define the edge basis functions, we can create a list called {\fontfamily{qcr}\selectfont EL} and one of the functions in this list will be represented as  
{\fontfamily{qcr}\selectfont 
tuple$([(0, 0, \text{leg}(j, z_{mid})*dx[0]*dy[0])])$,} where this tuple is acting as the function $z^j(x+1)(y+1)\text{ d}z$.  After we do that for each of the functions in {\fontfamily{qcr}\selectfont EL} and {\fontfamily{qcr}\selectfont FL}, we can then combine them together to create the basis for the trimmed serendipity $H($curl$)$ elements in a FIAT class.


%A code snippet of how this is done for the edge functions is given in Listing~\ref{lst:edge_basis_functions}.
 
 %\lstset{language=Python}
 %\begin{lstlisting}[frame=single, caption={Portion of edge basis function implementation.}, label={lst:edge_basis_functions}, numbers=left, firstnumber=1, xleftmargin=20pt, xrightmargin=20pt]]
%    def e_lambda_1_3d(deg, dx, dy, dz, x_mid, y_mid, z_mid):
%        EL = ()
%        for j in range(0, deg):
%            EL += tuple([(0, 0, leg(j, z_mid) * dx[0] * dy[0])])
%        for j in range(0, deg):
%            EL += tuple([(0, 0, leg(j, z_mid) * dx[0] * dy[1])])
%        for j in range(0, deg):
%            EL += tuple([(0, 0, leg(j, z_mid) * dx[1] * dy[0])])
%        for j in range(0, deg):
%            EL += tuple([(0, 0, leg(j, z_mid) * dx[1] * dy[1])])
%        ...
% \end{lstlisting}
 
 %After we create the edge basis functions and face basis functions, we can use those in the FIAT class we have defined for the trimmed serendipity $H($curl$)$ elements. %as seen in the Listing~\ref{lst:basis_functions}.  
 This is how we define the FIAT element that Firedrake is going to use when we request {\fontfamily{qcr}\selectfont SminusCurl} function spaces.  Next, FIAT does the numerical evaluation of the element and is wrapped into the FInAT element.  FInAT takes the numerical basis function tables and wraps them into an abstract syntax for table look-up.   
 
%\lstset{language=Python}
% \begin{lstlisting}[frame=single, caption={Collecting the basis functions for the trimmed serendipity class inside FIAT.}, label={lst:basis_functions}, numbers=left, firstnumber=1, xleftmargin=20pt, xrightmargin=20pt]] 
%    if dim == 3:
%        ...
%        EL = e_lambda_1_3d(degree, dx, dy, dz, x_mid, y_mid, z_mid)
%        if (degree > 1):
%            FL = f_lambda_1_3d(degree, dx, dy, dz, x_mid, y_mid, z_mid)
%        else:
%            FL = ()
%        if (degree > 3):
%            IL = I_lambda_1_3d(degree, dx, dy, dz, x_mid, y_mid, z_mid)
%        else:
%            IL = ()
%    
%        Sminus_list = EL + FL + IL
%        self.basis = {(0, 0, 0): Array(Sminus_list)}
%        super(TrimmedSerendipityCurl, self).__init__(ref_el=ref_el, 
%           degree=degree, mapping=contravariant piola)
%\end{lstlisting}

Additionally, there are small adjustments made to Firedrake's UFL and TSFC definitions so that each of the packages know to look for the trimmed serendipity elements.  The changes to TSFC and UFL are what then allow the user to make a call to the trimmed serendipity elements in a Firedrake code (see Listing~\ref{lst:pde_using_trimmed_serendipity}).

\lstset{language=Python}
\begin{lstlisting}[frame=single, caption={Setting up Firedrake to use the trimmed serendipity elements in a mixed Poisson problem in 3d.}, label={lst:pde_using_trimmed_serendipity}, numbers=left, firstnumber=1, xleftmargin=20pt, xrightmargin=20pt]] 
        ...
    PolyDegree = n
    Cells = 2**j
    msh = UnitSquareMesh(Cells, Cells, quadrilateral=True)
    mesh = ExtrudedMesh(msh, layers=Cells, layer_height=1/(Cells))
    
    Sminus = FunctionSpace(mesh, "SminusDiv", PolyDegree)
    DPC = FunctionSpace(mesh, "DPC", PolyDegree - 1)
    W = Sminus * DPC
        ...
\end{lstlisting}

  \section{Experiments}
    
The following experiments were designed to show the benefits and costs to using trimmed Serendipity elements in comparison to traditional tensor product elements.  We used a basic projection example to check implementation, as well as a primal Poisson problem (to test scalar elements), a mixed Poisson problem (to test H(div) elements), and a cavity resonator problem (to test H(curl) elements).  Note that the cavity resonator problem was done only in 3D, as the 2D H(curl) elements are just a rotation of the 2D H(div) elements. 
   
The experiments were performed on a single cluster compute node with 2x AMD EPYC 7642 48-core (Rome) processor, running at 2.4GHz and with 512GB of memory, with a few of the larger runs performed on a high memory node with 3TB of memory.  Each job was ran by submitting a slurm script that requested one node to itself to ensure no other jobs were running at the same time.  We utilized parallelism by executing the jobs with mpirun set up with 24 processes, with a few exceptions for smaller cases (that will be pointed out later).  Timing data was collected by having the slurm script do a dry run of code first to warm the cache and then three more consecutive runs, of which the minimum time was reported.  

%\josh{Somewhere in this section lead in we need to describe our experimental setup, which should include (1) hardware specifications and (2) software specifications (versions of firedrake, etc.)}

%\josh{On the hardware side, we can say something like ``all experiments were executed on a single cluster compute node with 2x AMD EPYC 7642 48-core (Rome) processor, running at 2.4GHz and with 512GB of memory.''  We should also indicate that are largest runs used a node with 3TB of memory}

%\josh{We should also state a little on how we executed these jobs, e.g. reveal some of the specs of the SLURM script we used, such as ``we utilized on node parallelism by executing these jobs with mpirun set up with KK processes''.}

%\josh{We'll also want to clarify if we had the node entirely cleared of other running jobs (I believe we did!) and thus we can modify the above to state it is free of other jobs.}

%\josh{We'll also want to mention things like ``cache warming'', ''how many runs you averaged together'', etc.  Anything we think a reasonably capable reader needs to know to reproduce our experimental results}

%\josh{Is the newpage intentional?}

%\newpage


  \subsection{Projection}
  
  We solve the projection problem to give a baseline of expectations for the elements. Given either the unit square or unit cube as our domain $\Omega$, we solve the equation 
  
  \begin{equation}
      \int u v  \text{ d}x = \int f v \text{ d}x \text{ for all v } \in V
  \end{equation}

 \noindent where $V$ is a test function space.   Recall that the trimmed Serendipity elements are denoted with $\mathcal{S}_r^-$ and the tensor product elements with $\mathcal{Q}^-_r$, and in Firedrake, these have a variety of names.  The trimmed serendipity elements, in both 2D and 3D, fall under the labels {\fontfamily{qcr}\selectfont SminusCurl} and {\fontfamily{qcr}\selectfont SminusDiv} for 1- and 2-forms respectively.  The tensor product elements use the labels {\fontfamily{qcr}\selectfont RTCE} (or {\fontfamily{qcr}\selectfont RTCF}) and  {\fontfamily{qcr}\selectfont NCE} for 1-forms in 2D and 3D, while the 2-forms in 3D are  {\fontfamily{qcr}\selectfont NCF}.  %\josh{What domain, how did you discretize it?  Mesh resolution, etc.?  May always want to clarify how we ``count'' things, e.g. compute error and count degrees of freedom (perhaps the latter is obvious though...it would be to me once i knew the mesh)}  

%\josh{We also probably want to state precisely the mapping from the legend in this diagram (e.g. $S^-_k$ and $Q^-_k$ to their names in specific Firedrake function spaces (perhaps though, this is obvious?}


\begin{figure}[h]
  \begin{subfigure}[h]{0.5\textwidth}
    %\includegraphics[height=2.2in]{2dProjectionH.pdf}
    \begin{tikzpicture}[scale=0.75]
      \begin{loglogaxis}[xlabel={h}, ylabel={Error},
             ylabel near ticks, ymax=1e-1, ymin=2e-11, xmax=0.3, xmin=0.5e-2,
             legend pos=south east, legend style={font=\tiny} ,
             cycle list name=color list, title={Projection Error Analysis in 2D}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionSminus2dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionSminus2dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionSminus2dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionRTCE2dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionRTCE2dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionRTCE2dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=h,y=Error,col sep=comma]{csvs/ProjectionSminus2dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=h,y=Error,col sep=comma]{csvs/ProjectionRTCE2dO2.csv};
        \addplot+[only marks, blue] table [x=h,y=Error,col sep=comma]{csvs/ProjectionSminus2dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=h,y=Error,col sep=comma]{csvs/ProjectionRTCE2dO3.csv};
        \addplot+[only marks, orange] table [x=h,y=Error,col sep=comma]{csvs/ProjectionSminus2dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=h,y=Error,col sep=comma]{csvs/ProjectionRTCE2dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
    \caption{2D edge length vs error}
    \label{fig:2dProjectionH}
  \end{subfigure}
  ~
  \begin{subfigure}[h]{0.5\textwidth}
     %\includegraphics[height=2.2in]{2dProjection.png}
     \begin{tikzpicture}[scale=0.75]
      \begin{loglogaxis}[xlabel={Degrees of Freedom}, ylabel={Error},
             ylabel near ticks, ymax=1e-1, ymin=2e-11, xmax=3e6, xmin=0.5e2,
             legend pos=south west, legend style={font=\tiny} ,
             cycle list name=color list, title={Projection Error Analysis in 2D}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionSminus2dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionSminus2dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionSminus2dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionRTCE2dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionRTCE2dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionRTCE2dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionSminus2dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionRTCE2dO2.csv};
        \addplot+[only marks, blue] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionSminus2dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionRTCE2dO3.csv};
        \addplot+[only marks, orange] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionSminus2dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionRTCE2dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
     \caption{2D degrees of freedom vs error}
     \label{fig:2dProjection}
  \end{subfigure} \\
  ~
  \begin{subfigure}[h]{0.5\textwidth}
    \begin{tikzpicture}[scale=0.75]
      \begin{loglogaxis}[xlabel={h}, ylabel={Error},
             ylabel near ticks, ymax=1e-1, ymin=2e-10, xmax=0.2, xmin=0.5e-2,
             legend pos=south east, legend style={font=\tiny} ,
             cycle list name=color list, title={Projection Error Analysis in 3D}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionSminus3dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionSminus3dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionSminus3dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionNCE3dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionNCE3dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=h,y=Error, col sep=comma]{csvs/ProjectionNCE3dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=h,y=Error,col sep=comma]{csvs/ProjectionSminus3dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=h,y=Error,col sep=comma]{csvs/ProjectionNCE3dO2.csv};
        \addplot+[only marks, blue] table [x=h,y=Error,col sep=comma]{csvs/ProjectionSminus3dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=h,y=Error,col sep=comma]{csvs/ProjectionNCE3dO3.csv};
        \addplot+[only marks, orange] table [x=h,y=Error,col sep=comma]{csvs/ProjectionSminus3dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=h,y=Error,col sep=comma]{csvs/ProjectionNCE3dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
    %\includegraphics[height=2.2in]{3dProjectionHError.pdf}
    \caption{3D edge length vs error}
    \label{fig:3dProjectionH}
  \end{subfigure}
  ~
  \begin{subfigure}[h]{0.5\textwidth}
  \begin{tikzpicture}[scale=0.75]
      \begin{loglogaxis}[xlabel={Degrees of Freedom}, ylabel={Error},
             ylabel near ticks, ymax=3e-2, ymin=0.5e-9, xmax=4e8, xmin=0.25e4,
             legend pos=south west, legend style={font=\tiny} ,
             cycle list name=color list, title={Projection Error Analysis in 3D}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionSminus3dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionSminus3dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionSminus3dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionNCE3dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionNCE3dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/ProjectionNCE3dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionSminus3dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionNCE3dO2.csv};
        \addplot+[only marks, blue] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionSminus3dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionNCE3dO3.csv};
        \addplot+[only marks, orange] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionSminus3dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/ProjectionNCE3dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
    %\includegraphics[height=2.2in]{3dProjectionDofsError.pdf}
    \caption{3D degrees of freedom vs error}
    \label{fig:3dProjectionDofs}
  \end{subfigure}
  \caption{Results of solving projection problem using 2D and 3D $S^-$ curl elements and tensor product curl elements.  A trendline being lower implies that for a similar mesh size, the error value is lower.} 
\end{figure}
\newpage

First, we graphed the errors from computing projections using trimmed Serendipity and tensor product elements in 2D, shown in Fig.~\ref{fig:2dProjectionH}.  Since we expect that the order of convergence for both of these elements should be the same (only off by a constant factor), we look for the lines representing trimmed Serendipity and tensor product elements at a given order to be parallel.
  
After checking that it is converging at the right rate, we then want to analyze the data from a standpoint of memory usage.  To do this, we plot degrees of freedom vs error, as seen in Fig.~\ref{fig:2dProjection}.  Overall, the error given by trimmed Serendipity elements is higher than the error from using tensor product elements of the same order.   We see similar results in Figs.~\ref{fig:3dProjectionDofs} and \ref{fig:3dProjectionH}.  Thus in the projection problem, while it is clear that the trimmed serendipity elements are acting as they are supposed to because of the parallel nature of the trendlines for $\calS^-$ and $\calQ^-$, it is also not beneficial to use the trimmed serendipity elements over the tensor product elements.


%\newpage
 



\subsection{The Poisson Problem}
In this section we discuss results for both the primal Poisson problem as well as the mixed Poisson problem.  We solve the primal Poisson problem described below on a unit square domain $\Omega$:
\begin{align}
    -\nabla^2 u &= f \\
    u\vert_{\partial \Omega} &= 0
\end{align}
where $f(x,y) = 3\pi^2\text{sin}(\pi x)\text{sin}(\pi y) $, yielding the solution $u(x,y) = \text{sin}(\pi x)\text{sin}(\pi y)$. In 3D, we can extend this to $f(x,y,z) = 2\pi^2\text{sin}(\pi x)\text{sin}(\pi y)\text{sin}(\pi z)$ with the solution being $u(x,y,z) = \text{sin}(\pi x)\text{sin}(\pi y)\text{sin}(\pi z)$.  By multiplying by a test function and integrating by parts, then applying the boundary condition, we get the weak form of the Poisson problem:

\begin{equation}
    \int_\Omega \nabla u \cdot \nabla v \text{ d}x = \int_\Omega f v \text{ d}x
\end{equation}

\noindent such that the weak form equation holds for all $v$ in the test function space.

The primal Poisson problem allows us to test scalar (trimmed) serendipity elements against Lagrange elements.  Then we wish to also test H(div) elements.  To do this, we solve a discretization of the mixed Poisson problem:

\begin{align}
     \sigma - \nabla u &= 0 \\
     \nabla \cdot \sigma &= -f  \\
     u\vert_{\partial \Omega} &= 0 
\end{align}

In a similar fashion as for the primal Poisson problem, we can create the weak formulation of the mixed Poisson problem.  This results in the weak form being given by

\begin{equation}
    \int_\Omega \sigma \cdot \tau + \nabla \cdot \tau u + \nabla \cdot \sigma v \text{ d}x = - \int_\Omega fv \text{ d}x
\end{equation}

\noindent for all $\tau, v$ in the appropriate test function spaces.  

\begin{figure}[h!]
  \centering
  \begin{subfigure}[h]{0.5\textwidth}
    \centering
      \begin{tikzpicture}[scale=0.88]
      \begin{loglogaxis}[xlabel={Degrees of Freedom}, ylabel={Error},
             ylabel near ticks, ymax=1e-4, ymin=1e-16, xmax=2e6, xmin=2e3,
             legend pos=south west, legend style={font=\tiny} ,
             cycle list name=color list, title={Primal Poisson Error Analysis}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonSerendipity2dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonSerendipity2dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonSerendipity2dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonLagrange2dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonLagrange2dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonLagrange2dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonSerendipity2dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonLagrange2dO2.csv};
        \addplot+[only marks, blue] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonSerendipity2dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonLagrange2dO3.csv};
        \addplot+[only marks, orange] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonSerendipity2dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonLagrange2dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
    %\includegraphics[height=2.2in]{2dPrimalPoisson.png}
    \caption{2D Primal}
    \label{fig:2dPrimalDofs}
  \end{subfigure}
  ~
  \begin{subfigure}[h]{0.5\textwidth}
    \centering
    \begin{tikzpicture}[scale=0.88]
      \begin{loglogaxis}[xlabel={Degrees of Freedom}, ylabel={Error},
             ylabel near ticks, ymax=1e-1, ymin=1e-11, xmax=2e6, xmin=3e2,
             legend pos=south west, legend style={font=\tiny} ,
             cycle list name=color list, title={Mixed Poisson Error Analysis}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonSminus2dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonSminus2dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonSminus2dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonRTCF2dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonRTCF2dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonRTCF2dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonSminus2dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonRTCF2dO2.csv};
        \addplot+[only marks, blue] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonSminus2dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonRTCF2dO3.csv};
        \addplot+[only marks, orange] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonSminus2dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonRTCF2dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
    %\includegraphics[height=2.2in]{2dMixedPoissonDofs.pdf}
    \caption{2D Mixed}
    \label{fig:2dMixedDofsError}
  \end{subfigure} \\
  \begin{subfigure}[h]{0.5\textwidth}
    \centering
    \begin{tikzpicture}[scale=0.88]
      \begin{loglogaxis}[xlabel={Degrees of Freedom}, ylabel={Error},
             ylabel near ticks, ymax=1e-3, ymin=1e-11, xmax=2e8, xmin=1e3,
             legend pos=south west, legend style={font=\tiny} ,
             cycle list name=color list, title={Primal Poisson Error Analysis}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonSerendipity3dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonSerendipity3dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonSerendipity3dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonLagrange3dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonLagrange3dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/PrimalPoissonLagrange3dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonSerendipity3dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonLagrange3dO2.csv};
        \addplot+[only marks, blue] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonSerendipity3dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonLagrange3dO3.csv};
        \addplot+[only marks, orange] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonSerendipity3dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/PrimalPoissonLagrange3dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
    %\includegraphics[height=2.2in]{3dPrimalDofsError.pdf}
    \caption{3D Primal}
    \label{fig:3dPrimalDofsError}
  \end{subfigure}
  ~
  \begin{subfigure}[h]{0.5\textwidth}
    \centering
    %\includegraphics[height=2.2in]{3dMixedPoissonDofsError.pdf}
    \begin{tikzpicture}[scale=0.88]
      \begin{loglogaxis}[xlabel={Degrees of Freedom}, ylabel={Error},
             ylabel near ticks, ymax=1.2e-2, ymin=0.8e-7, xmax=2e7, xmin=5e3,
             legend pos=south west, legend style={font=\tiny} ,
             cycle list name=color list, title={Mixed Poisson Error Analysis}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonSminus3dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonSminus3dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonSminus3dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonNCF3dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonNCF3dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=Dofs,y=Error, col sep=comma]{csvs/MixedPoissonNCF3dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonSminus3dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonNCF3dO2.csv};
        \addplot+[only marks, blue] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonSminus3dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonNCF3dO3.csv};
        \addplot+[only marks, orange] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonSminus3dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=Dofs,y=Error,col sep=comma]{csvs/MixedPoissonNCF3dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
    \caption{3D Mixed}
    \label{fig:3dMixedDofsError}
  \end{subfigure}
  \caption{An error analysis of the primal and mixed Poisson problems in 2D and 3D.}
\label{fig:PrimalMixedErrorAnalysis}
\end{figure}


The error analysis results for the primal Poisson and mixed Poisson problems can be seen in Figs.~\ref{fig:2dPrimalDofs}, \ref{fig:2dMixedDofsError}, \ref{fig:3dPrimalDofsError}, and \ref{fig:3dMixedDofsError}.  In each of the figures in \ref{fig:PrimalMixedErrorAnalysis}, we see that independent of the performance of each element, they all follow similar trajectories again, indicating that they have the same overall convergence rate.  The primal Poisson problem shows us that there are scenarios where using trimmed serendipity elements can be beneficial in terms of error depending on the number of degrees of freedom.  However, in the mixed Poisson problem, we don't immediately see this benefit in either the 2D case or the 3D case.

We would also like to analyze timing for tensor product elements and trimmed Serendipity elements.  We show this comparison in Fig.~\ref{fig:PrimalMixedTimeAnalysis}.  In \ref{fig:3dPrimalDofsTime} and \ref{fig:3dPrimalTimeError}, we see good evidence that Serendipity elements are able to to produce better results at a faster rate.  Specifically, in \ref{fig:3dPrimalDofsTime}, we can see that Serendipity elements are able to do a larger number of degrees of freedom in the same amount of time.  In fig \ref{fig:3dPrimalTimeError} we see that for a given error level, Serendipity elements require less time.

However the picture that is painted in \ref{fig:3dMixedDofsTime} and \ref{fig:3dMixedTimeError} is much less clear.  Overall, trimmed Serendipity elements seem to do a bit worse than the corresponding tensor product elements for the mixed Poisson problem, but it is promising that in \ref{fig:3dMixedDofsTime}, the points tend to stay in an overall linear fashion bunched together. 

%\newpage

\begin{figure}[ht]
  \centering
  \begin{subfigure}[h]{0.5\textwidth}
    \centering
          \begin{tikzpicture}[scale=0.88]
      \begin{loglogaxis}[xlabel={Degrees of Freedom}, ylabel={Time},
             ylabel near ticks, ymax=1.e+4, ymin=0.5e-1, xmax=2.e8, xmin=1.e+3,
             legend pos=north west, legend style={font=\tiny} ,
             cycle list name=color list, title={Primal Poisson using $S^-$ and $Q^-$}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=Dofs,y=Time, col sep=comma]{csvs/PrimalPoissonSerendipity3dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=Dofs,y=Time, col sep=comma]{csvs/PrimalPoissonSerendipity3dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=Dofs,y=Time, col sep=comma]{csvs/PrimalPoissonSerendipity3dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=Dofs,y=Time, col sep=comma]{csvs/PrimalPoissonLagrange3dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=Dofs,y=Time, col sep=comma]{csvs/PrimalPoissonLagrange3dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=Dofs,y=Time, col sep=comma]{csvs/PrimalPoissonLagrange3dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=Dofs,y=Time,col sep=comma]{csvs/PrimalPoissonSerendipity3dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=Dofs,y=Time,col sep=comma]{csvs/PrimalPoissonLagrange3dO2.csv};
        \addplot+[only marks, blue] table [x=Dofs,y=Time,col sep=comma]{csvs/PrimalPoissonSerendipity3dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=Dofs,y=Time,col sep=comma]{csvs/PrimalPoissonLagrange3dO3.csv};
        \addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{csvs/PrimalPoissonSerendipity3dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=Dofs,y=Time,col sep=comma]{csvs/PrimalPoissonLagrange3dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
    %\includegraphics[height=2.2in]{3dPrimalDofsTime.pdf}
    \caption{3D Primal Degrees of freedom vs Time}
    \label{fig:3dPrimalDofsTime}
  \end{subfigure}
  ~
  \begin{subfigure}[h]{0.5\textwidth}
    \centering
    \begin{tikzpicture}[scale=0.88]
      \begin{loglogaxis}[xlabel={Time}, ylabel={Error},
             ylabel near ticks, ymax=1e-3, ymin=1e-11, xmax=1e4, xmin=0.5e-1,
             legend pos=north east, legend style={font=\tiny} ,
             cycle list name=color list, title={Primal Poisson using $S^-$ and $Q^-$}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=Time,y=Error, col sep=comma]{csvs/PrimalPoissonSerendipity3dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=Time,y=Error, col sep=comma]{csvs/PrimalPoissonSerendipity3dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=Time,y=Error, col sep=comma]{csvs/PrimalPoissonSerendipity3dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=Time,y=Error, col sep=comma]{csvs/PrimalPoissonLagrange3dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=Time,y=Error, col sep=comma]{csvs/PrimalPoissonLagrange3dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=Time,y=Error, col sep=comma]{csvs/PrimalPoissonLagrange3dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=Time,y=Error,col sep=comma]{csvs/PrimalPoissonSerendipity3dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=Time,y=Error,col sep=comma]{csvs/PrimalPoissonLagrange3dO2.csv};
        \addplot+[only marks, blue] table [x=Time,y=Error,col sep=comma]{csvs/PrimalPoissonSerendipity3dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=Time,y=Error,col sep=comma]{csvs/PrimalPoissonLagrange3dO3.csv};
        \addplot+[only marks, orange] table [x=Time,y=Error,col sep=comma]{csvs/PrimalPoissonSerendipity3dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=Time,y=Error,col sep=comma]{csvs/PrimalPoissonLagrange3dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
    %\includegraphics[height=2.2in]{3dPrimalTimeError.pdf}
    \caption{3D Primal Time vs Error}
    \label{fig:3dPrimalTimeError}
  \end{subfigure}\\
  ~
  \begin{subfigure}[h]{0.5\textwidth}
    \centering
    \begin{tikzpicture}[scale=0.88]
      \begin{loglogaxis}[xlabel={Degrees of Freedom}, ylabel={Time},
             ylabel near ticks, ymax=2e4, ymin=1e-1, xmax=2e7, xmin=0.5e4,
             legend pos=north west, legend style={font=\tiny} ,
             cycle list name=color list, title={Mixed Poisson using $S^-$ and $Q^-$}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=Dofs,y=Time, col sep=comma]{csvs/MixedPoissonSminus3dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=Dofs,y=Time, col sep=comma]{csvs/MixedPoissonSminus3dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=Dofs,y=Time, col sep=comma]{csvs/MixedPoissonSminus3dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=Dofs,y=Time, col sep=comma]{csvs/MixedPoissonNCF3dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=Dofs,y=Time, col sep=comma]{csvs/MixedPoissonNCF3dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=Dofs,y=Time, col sep=comma]{csvs/MixedPoissonNCF3dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=Dofs,y=Time,col sep=comma]{csvs/MixedPoissonSminus3dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=Dofs,y=Time,col sep=comma]{csvs/MixedPoissonNCF3dO2.csv};
        \addplot+[only marks, blue] table [x=Dofs,y=Time,col sep=comma]{csvs/MixedPoissonSminus3dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=Dofs,y=Time,col sep=comma]{csvs/MixedPoissonNCF3dO3.csv};
        \addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{csvs/MixedPoissonSminus3dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=Dofs,y=Time,col sep=comma]{csvs/MixedPoissonNCF3dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
    %\includegraphics[height=2.2in]{3dMixedPoissonDofsTime.pdf}
    \caption{3D Mixed Degrees of freedom vs Time}
    \label{fig:3dMixedDofsTime}
  \end{subfigure}
  ~
  \begin{subfigure}[h]{0.5\textwidth}
    \centering
    \begin{tikzpicture}[scale=0.88]
      \begin{loglogaxis}[xlabel={Time}, ylabel={Error},
             ylabel near ticks, ymax=1e-1, ymin=5e-8, xmax=1e5, xmin=0.5e-1,
             legend pos=north east, legend style={font=\tiny} ,
             cycle list name=color list, title={Mixed Poisson using $S^-$ and $Q^-$}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[red]
        table [x=Time,y=Error, col sep=comma]{csvs/MixedPoissonSminus3dO2.csv};
        \addlegendentry{$S^-_2$}
        \addplot[blue] 
        table [x=Time,y=Error, col sep=comma]{csvs/MixedPoissonSminus3dO3.csv};
        \addlegendentry{$S^-_3$ }
        \addplot[orange]
        table [x=Time,y=Error, col sep=comma]{csvs/MixedPoissonSminus3dO4.csv};
        \addlegendentry{$S^-_4$}
        \addplot[densely dotted, red]
        table [x=Time,y=Error, col sep=comma]{csvs/MixedPoissonNCF3dO2.csv};
        \addlegendentry{$Q^-_2$}
        \addplot[densely dotted, blue] 
        table [x=Time,y=Error, col sep=comma]{csvs/MixedPoissonNCF3dO3.csv};
        \addlegendentry{$Q^-_3$}
        \addplot[densely dotted, orange]
        table [x=Time,y=Error, col sep=comma]{csvs/MixedPoissonNCF3dO4.csv};
        \addlegendentry{$Q^-_4$}
        
        \addplot+[only marks, red] table [x=Time,y=Error,col sep=comma]{csvs/MixedPoissonSminus3dO2.csv};
        \addplot+[only marks, red, mark=square*] table [x=Time,y=Error,col sep=comma]{csvs/MixedPoissonNCF3dO2.csv};
        \addplot+[only marks, blue] table [x=Time,y=Error,col sep=comma]{csvs/MixedPoissonSminus3dO3.csv};
        \addplot+[only marks, blue, mark=square*] table [x=Time,y=Error,col sep=comma]{csvs/MixedPoissonNCF3dO3.csv};
        \addplot+[only marks, orange] table [x=Time,y=Error,col sep=comma]{csvs/MixedPoissonSminus3dO4.csv};
        \addplot+[only marks, orange, mark=square*] table [x=Time,y=Error,col sep=comma]{csvs/MixedPoissonNCF3dO4.csv};
      \end{loglogaxis}
      \end{tikzpicture}
    %\includegraphics[height=2.2in]{3dMixedPoissonTimeError.pdf}
    \caption{3D Mixed Time vs Error}
    \label{fig:3dMixedTimeError}
  \end{subfigure}
  \caption{Analyzing timing data for primal and mixed Poisson problems using trimmed Serendipity and tensor product elements.}
\label{fig:PrimalMixedTimeAnalysis}
\end{figure}


\newpage  
  
\newpage 



\subsection{Cavity Resonator}

For testing the H$($curl$)$ elements in 3D, we use the cavity resonator problem.  Here, the time-harmonic Maxwell equations are applied to a domain $\Omega = [0,1]^3$ with perfectly conducting boundary conditions, yielding an eigenvalue problem where $\lambda$ represents a quantity proportional to the frequency squared of the time-harmonic electric field (i.e.\ eigenvalues) and $E$ represents the electric field (i.e.\ eigenfunctions):

\begin{align}
    \nabla \cdot E &= 0 \text{ in } \Omega \\
    \nabla \times \nabla \times E &= \lambda E  \text{ in } \Omega \\
    E \times n &= 0 \text{ on } \partial \Omega.
\end{align}

Then, we consider the weak formulation of this problem (similar to \cite{fumio1987mixed}), where $\omega$ represents the resonances (i.e.\ eigenvalues) and $E$ represents the electric field (i.e.\ eigenfunctions):

\begin{equation}
    \int_\Omega \big(\nabla \times F\big) \cdot \big(\nabla \times E \big) \text{ d}x = \omega^2 \int_\Omega F \cdot E \text{ d}x \text{ for all } F \in H_0(\text{curl}).
    %\langle \text{curl}(F), \text{curl}(E) \rangle = \omega^2 \langle F, E \rangle \text{ for all } F \in H_0(\text{curl}).
\end{equation}

%\noindent We tested out the H$($curl$)$ elements in 3D on the cavity resonator problem, where the time-harmonic Maxwell equations applied to a 
%\akg{(1) The wording is a little ambiguous - are you about the state the resonator problem or Maxwell's equations?  Or are these the same?  (2) I prefer to see the statement of the variables prior to the PDE i.e. move the part after the equation to before it. (3) You need to state the domain - I think it's $[0,1]^3\subset\R^3$ - and the boundary conditions (periodic?) (4) Give the eigenvalue equation a label so you can reference it later.}

\noindent The exact eigenvalues should follow the formula

\[ \omega^2 = m_1^2 + m_2^2 + m_3^2 \]

\noindent where $m_i \in \mathbb{N} \cup {0}$ and no more than one of $m_1, m_2, m_3$ may be equal to $0$ at a time \cite{rognes2010efficient}.

%\akg{Put discretized version of eigenvalue problem here (see comment below)}

\begin{center}
\begin{table}
\begin{tabular}{ c c c c c }
\multicolumn{5}{c}{NCE Elements} \\
\hline
Actual & N = 4 & N = 8 & N = 16 & N = 32 \\ 
\hline
2 (3) &2.001024 & 2.000066 (3.96) & 2.000004 (4.04) & 2.0000003 (4.00) \\  
3 (2) & 3.001536 & 3.000098 (3.97) & 3.000006 (4.03) & 3.0000004 (4.02) \\
5 (4) & 5.030601 & 5.002081 (3.88)& 5.000133 (3.97) & 5.000008 (4.06) \\
6 (3) & 6.031114 & 6.002114 (3.88) & 6.000135 (3.97) &  6.000008 (4.08) \\
8 (0) & - & -& - & - \\
\hline
%Iterations & 4 & 4 & 3 & 5 \\
%\hline
DOF  & 1944 & 13872 & 104544 & 811200 \\
\hline
EPS solve time per iteration & 0.01565225 & 0.0743845 & 1.0484236 & 7.6186526 \\
\hline
\multicolumn{5}{c}{$S^-$ H$($curl$)$ Elements} \\
\hline
Actual & N = 4 & N = 8 & N = 16 & N = 32 \\ 
\hline
2 (3) & 2.001092 & 2.000066 (4.05) & 2.000004 (4.04) & 2.000000 (4.00) \\  
3 (2) & 3.009018 & 3.000586 (3.94) & 3.000037 (3.99) & 3.000002 (4.21) \\
5 (3) & 5.032027 & 5.002097 (3.93)& 5.000133 (3.98) & 5.000008 (4.06) \\
5 (1) & 5.032027 & 5.002097 (3.93) & 5.000133 (3.98) & - \\
6 (1) & 6.072012 & 6.004976 (3.86) & 6.000319 (3.96) & 6.000020 (4.00) \\
6 (1) & 6.072012 & 6.004976 (3.86) & 6.000319 (3.96) & 6.000024 (3.73)\\
6 (1) & - & - & 6.00038 & 6.000024 (3.98)\\
8 (1) & - & - & - & 8.000017 \\
\hline
DOF  & 1080 & 7344 & 53856 & 411840 \\
\hline
EPS solve time per iteration & 0.01288725 & 0.0309768 & 0.401663 & 4.1996873 \\
\hline

\end{tabular}
\caption{A comparison of how order 2 NCE and $S^-$ finite elements solve the Maxwell cavity resonator eigenvalue problem, $\langle \text{curl}(F), \text{curl}(E) \rangle = \omega^2 \langle F, E \rangle$. An eigenvalue found with the same error multiple times was condensed to a single row.}  
\label{tab:Eigenvalue}
\end{table}
\end{center}

In Table~\ref{tab:Eigenvalue}, we look at the convergence rates of different eigenvalues based off solving the problem with tensor product (NCE) elements and trimmed Serendipity ($S^-$) elements in 3D.  The table is split into two mirrored halves, the top half giving values from using NCE elements while the bottom half gives values from using $S^-$ elements.  The column labeled ``Actual'' represents the theoretical eigenvalue that eigenvalues in that row are converging towards and gives a number in the parentheses that indicates the number of times the eigensolver found that eigenvalue with the exact same set of error values.  Each of the $N=4, N=8, N=16, N=32$ columns represents the approximate eigenvalues calculated on a mesh of size $N x N x N$.  The number in parenthesis next to approximate eigenvalues is the rate of convergence of that eigenvalue.  Finally, each half has a row giving the overall degrees of freedom in the mesh at each given mesh size and another row that gives the time that the eigenvalue solver needed to find the requested number of eigenvalues.


Note that the convergence rates are computed by doing

\[r = \frac{\text{log}\bigg(\frac{\tilde{\lambda}_{i,N} - \lambda_{i,N}}{\tilde{\lambda}_{i,N+1} - \lambda_{i,N+1}} \bigg)}{\text{log}\bigg( \frac{h_N}{h_{N+1}} \bigg)} \]

\noindent and are indicated in the chart by using parentheses.  We use H$($curl$)$ to solve the problems, corresponding with edge elements in 3D.  Based off earlier eigenvalue works \cite{boffi2010finite}, we expect that the rate of convergence be double the order of the finite element used to solve the problem.  This is reflected in the table relatively well for both $S^-$ and NCE elements.  Any eigenvalue that has a $-$ spot is to be interpreted as the eigenvalue solver did not find that specific eigenvalue in the number of iterations it required to find the first 15 requested eigenvalue-eigenvector pairs.

The experiment was done by using SLEPc in Firedrake, computing an inverted shift to a target of $3.0$, then asking SLEPc for $15$ eigenvalue-eigenvector pairs.  SLEPc was then give a tolerance level of $1\text{e}-7$, and a couple of specific mumps parameters (icntl 14 set to 200 and icntl 13 set to 1).  We ignored the eigenvalues of $1$, as they correspond only to the boundary conditions. 

Knowing that both elements are solving this problem in a fashion that is expected theoretically, we can analyze the rest of the results shown in this table.  Investigating the error in the eigenvalues in the chart compared to the exact values, we see that NCE elements are able to get results that are up to a magnitude better near the target eigenvalue.  On the other hand, this loss of accuracy from using trimmed Serendipity elements results in a significant reduction in required time to solve for the requested eigenvalues.  At every mesh refinement level, trimmed Serendipity elements have nearly half the DOFs of NCE elements, and correspondingly, require about half the time to solve for the eigenvalues.  At higher orders, we expect that this will be even more exaggerated.  

Finally, we wanted to analyze the timing results for the eigenvalue problem more carefully.  We sent Firedrake, using the SLEPc tools, to solve the same Maxwell Cavity Eigenvalue problem, but instead of refining the mesh, we chose to increase the order of the elements used from order$r=2$ to $r=5$ while holding the mesh steady at a size of $16 \times 16 \times 16$.  Then for the results we choose two specific eigenvalues of $\lambda = 3$ and $\lambda = 5$ and choose the timing data based on the largest time required for any of the multiplicities that are found. 

\begin{figure}[ht]
  \centering
  \begin{subfigure}[h]{0.5\textwidth}
  \centering
  \begin{tikzpicture}[scale=0.7]
      \begin{loglogaxis}[xlabel={Dofs}, ylabel={Error},
             ylabel near ticks, ymax=1e-3, ymin=1e-14, xmax=3e6, xmin=3.5e4,
             legend pos=north east, legend style={font=\tiny} ,
             cycle list name=color list, title={Maxwell Eigenvalue Analysis}]
        %\addplot+[only marks, orange] table [x=Dofs,y=Time,col sep=comma]{PrimalPoissonSerendipity3dO4.csv};
        \addplot[green, mark=diamond]
        table [x=Dofs,y=Error, col sep=comma]{csvs/SminusEigenvaluesValue3.csv};
        \addlegendentry{$S^- \lambda = 3$}
        \addplot[densely dotted, green, mark=square*]
        table [x=Dofs,y=Error, col sep=comma]{csvs/TensorEigenvaluesValue3.csv};
        \addlegendentry{$Q^- \lambda = 3$}
        \addplot[violet, mark=diamond] 
        table [x=Dofs,y=Error, col sep=comma]{csvs/SminusEigenvaluesValue5.csv};
        \addlegendentry{$S^- \lambda = 5$ }
        \addplot[densely dotted, violet, mark=square*]
        table [x=Dofs,y=Error, col sep=comma]{csvs/TensorEigenvaluesValue5.csv};
        \addlegendentry{$Q^- \lambda = 5$}
      \end{loglogaxis}
      \end{tikzpicture}
      \caption{Eigenvalue error analysis.}
      \label{fig:EigenvalueDofsError}
     \end{subfigure}
  ~
  \begin{subfigure}[h]{0.5\textwidth}
    \centering
    \begin{tikzpicture}[scale=0.7]
      \begin{loglogaxis}[xlabel={Time}, ylabel={Error},
             ylabel near ticks, ymax=1e-3, ymin=1e-14, xmax=185, xmin=0,
             legend pos=north east, legend style={font=\tiny} ,
             cycle list name=color list, title={Maxwell Eigenvalue Analysis}]
        \addplot[green, mark=diamond]
        table [x=Time,y=Error, col sep=comma]{csvs/SminusEigenvaluesValue3.csv};
        \addlegendentry{$S^- \lambda = 3$}
        \addplot[densely dotted, green, mark=square*]
        table [x=Time,y=Error, col sep=comma]{csvs/TensorEigenvaluesValue3.csv};
        \addlegendentry{$Q^- \lambda = 3$}
        \addplot[violet, mark=diamond] 
        table [x=Time,y=Error, col sep=comma]{csvs/SminusEigenvaluesValue5.csv};
        \addlegendentry{$S^- \lambda = 5$ }
        \addplot[densely dotted, violet, mark=square*]
        table [x=Time,y=Error, col sep=comma]{csvs/TensorEigenvaluesValue5.csv};
        \addlegendentry{$Q^- \lambda = 5$}
      \end{loglogaxis}
      \end{tikzpicture}
    %\includegraphics[height=2.2in]{3dPrimalTimeError.pdf}
    \caption{Eigenvalue time analysis.}
    \label{fig:EigenvalueTimeError}
  \end{subfigure}\\
  \caption{Results for solving for $\lambda = 3$ and $\lambda = 5$ using Firedrake and SLEPc by increasing the order from $2$ to $5$.}
\label{fig:EigenvalueAnalysis}
\end{figure}

The error results shown in \ref{fig:EigenvalueDofsError} for the eigenvalue problem give trimmed serendipity elements an application where the same degrees of freedom can result in an improvement of accuracy in the eigenvalues that are found.  This is a change from the mixed Poisson problem where the DOFs vs Error trendline for trimmed serendipity was generally above the trendline for tensor product elements.  However, it is important to note that the refinement was done differently in the case of the eigenvalue problem.  In order to achieve a higher count of DOFs, we increased the order $r$ for $\mathcal{S}^-_r$ and $\mathcal{Q}^-_r$ rather than refining the mesh as was done in the mixed Poisson problem experiments.  The timing results in \ref{fig:EigenvalueTimeError} for the trimmed serendipity elements were similarly better for the eigenvalue problem in comparison to the tensor product elements.


\section{Discussion}

Each finite element has a time and place where it could be considered beneficial to use.  We explored the numerical properties of trimmed Serendipity elements to refine our understanding of how they act.  From the theory, we knew that trimmed Serendipity elements should be able to converge at the same rate as tensor product and Serendipity elements, while using fewer degrees of freedom overall.  The plots here demonstrate that the rate of convergence is consistent with that theory at orders $2, 3$ and $4$ for H$($curl$)$, H$($div$)$, and $H^1$ elements in both 2 and 3D.  These experiments also confirmed that as the degree of the elements increased, the number of degrees of freedom for trimmed serendipity elements were approximately half the degrees of freedom that the tensor product elements used.

There are two scenarios where the use of trimmed serendipity elements might be beneficial.  The first is when the speed of the solve matters.  The second is when the memory that the solve requires is limited.  In both of these scenarios, the smaller amount of degrees of freedom required for trimmed serendipity elements is a benefit that users can take advantage of in order to meet one of these two limitations.  

Even in the reigme of analyzing dofs vs error, the eigenvalue problem illustrates that a straightforward comparison of the tensor product and trimmed serendipity elements does not yield a simple answer pointing towards one of these two elements being better in all scenarios.  The eigenvalue problem specific seems to indicate that refining along the order of the element, rather than the size of the cells of the mesh, may result in saving time and memory on the machine while still being able to attain the same levels of error.

The trimmed serendipity elements are not perfect, and will not replace the tensor product elements entirely.  The results here show that while tensor product elements require more computational effort, they are also more accurate the trimmed serendipity elements.  Therefore, if the goal of a user is to find the most accurate solution, regardless of the time required to do so, tensor product elements will do this better than trimmed serendipity elements.  Even then, in some scenarios, it is likely that tensor product elements can fare even better by using tricks that take advantage of the inherent symmetry in the elements.  

In the future, we would like to apply the trimmed serendipity elements to some large scale engineering problems to test them in a more industrial scenario.  This will give more insight as to their benefits in a real world application.  We would also like to spend time implementing the (ordinary) serendipity vector elements that are  missing from Firedrake.  Currently Firedrake has the serendipity elements in 2D, as well the $H^1$-conforming elements and $L^2$-conforming elements in 3D.  Vector serendipity elements are still a work in progress.

%Beyond the convergence rates hitting what we expect, we were able to analyze memory usage on these problems by studying the degrees of freedom required.  Trimmed Serendipity, while generally have a worse error at a given order $k$, also uses significantly fewer degrees of freedom.  This is illustrated well in the Maxwell Cavity Eigenvalue problem in \ref{tab:Eigenvalue}, where the degrees of freedom required were nearly half of what the tensor product elements used.  \\

%Another example of this is the 3D mixed Poisson problem, where we see that the trimmed Serendipity elements are able to be used at more refined meshes while the tensor product elements would need to be allotted more time on a high memory computer to be able to get results on the same sized mesh.  \\

%In general, it is clear from these results that trimmed Serendipity is not always a better choice compared to tensor product elements.  However, these examples illustrates the benefit of trimmed Serendipity elements--in a setting where the mesh is fixed, the option to use a trimmed Serendipity element might give an extra way to refine a problem to increase the accuracy of a solution.
    

\bibliographystyle{ACM-Reference-Format}  %Might need acmart.cls (unclear)
\bibliography{serendipityFiredrakePaper}  %Change this to the bib file

\end{document}
